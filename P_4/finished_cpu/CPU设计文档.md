设计草稿
--
将32位单周期CPU分成alu,ctrl,dm,dp,ext,grf,ifu,npc,split六个部分，
分别对各个部分进行设计

1. IFU部分包括PC和IM（Introduction Memory），IM地址位宽为5

|端口|方向|位宽|功能|
|--|--|--|--|
|NPC|input|32|输入下一个PC
|RESET|input|1|重置PC
|CLK|input|1|时钟
|PC|output|[31:0]|输出当前PC
|Instr|output|[31:0]|输出指令


2. GRF包括32个32位寄存器

|端口|方向|位宽|功能|
|--|--|--|--|
|A1|input|[4:0]|第一个读取地址
|A2|input|[4:0]|第二个读取地址
|A3|input|[4:0]|写入地址
|WD|input|[31:0]|写入数据
|CLK|input|1|时钟
|RESET|input|1|重置
|RD1|output|[31:0]|第一个地址里的数据
|RD2|output|[31:0]|第二个地址里的数据

3. ALU实现多种运算

|端口|方向|位宽|功能|
|--|--|--|--|
|A|input|[31:0]|第一个操作数
|B|input|[31:0]|第二个操作数
|ALUctrl|input|[3:0]|功能控制信号
|ZERO|output|1|两个操作数是否相等
|C|output|[31:0]|运算结果

其中各个ALUctrl对应的功能
|ALUctrl|功能|
|--|--|
|0000|AandB|
|0001|AorB|
|0010|AxorB|
|0011|A+B|
|0100|A-B|
|0101|MUL_LO|
|0110|MUL_HI|
|0111|DIV_LO|
|1000|DIV_HI|
|1001|SLL|
|1010|SRL|
|1011|SLT|
|1100|SGE|

4. DM（Data Memory），位宽为5

|端口|方向|位宽|功能|
|--|--|--|--|
|A|input|[4:0]|选择地址|
|D|input|[31:0]|写入数据|
|WE|input|1|写使能|
|CLK|input|1|时钟|
|RESET|input|1|重置|
|D|output|[31:0]|读出数据|

5. EXT可以进行符号扩展、0扩展、16位数移到高位

|端口|方向|位宽|功能|
|--|--|--|--|
|ExtOp|input|[1:0]|控制信号
|imm16|input|[15:0]|输入16位立即数
|ext32|output|[31:0]|输出32位结果

|ExtOp|功能|
|--|--|
|00|零扩展|
|01|符号扩展|
|10|移高位|

6. Controller控制通路

|端口|方向|位宽|功能|
|--|--|--|--|
|op|input|[5:0]|指令op段|
|funct|input|[5:0]|指令funct段|
|RegDst|output|1|多路选择器开关|
|ALUsrc|output|1|多路选择器开关|
|MemtoReg|output|1|多路选择器开关|
|MemWrite|output|1|多路选择器开关|
|JR|output|1|是否进行JR指令|
|ExtOp|output|[1:0]|符号扩展信号|
|ALUctrl|output|[3:0]|ALU功能选择信号|

通路设计

| c        | 10_0000 | 10_0001 | 10_0010  | 10_0011  | 10_0101 | 00_0000 |         |         |         |         |          |          |         |         |         |         | 00_1000 |   |   |
|----------|---------|---------|----------|----------|---------|---------|---------|---------|---------|---------|----------|----------|---------|---------|---------|---------|---------|---|---|
| op       | 00_0000 | 00_0000 | 00_0000  | 00_0000  | 00_0000 | 00_0000 | 00_0000 | 00_1101 | 10_0011 | 10_1011 | 00_0101  | 00_0100  | 00_1111 | 00_1000 | 00_0010 | 00_0011 | 00_0000 |   |   |
|          | add     | addu    | sub      | subu     | or      | sll     | slt     | ori     | lw      | sw      | bne      | beq      | lui     | addi    | j       | jal     | jr      |   |   |
| RegDst   | 1       | 1       | 1        | 1        | 1       | 1       | 1       | 0       | 0       | x       | x        | x        | 0       | 0       | x       | x       |         |   |   |
| ALUSrc   | 0       | 0       | 0        | 0        | 0       | 0       | 0       | 1       | 1       | 1       | 0        | 0        | 1       | 1       | x       | x       |         |   |   |
| MemtoReg | 0       | 0       | 0        | 0        | 0       | 0       | 0       | 0       | 1       | x       | x        | x        | 0       | 0       | x       | 0       |         |   |   |
| RegWrite | 1       | 1       | 1        | 1        | 1       | 1       | 1       | 1       | 1       | 0       | 0        | 0        | 1       | 1       | 0       | 1       |         |   |   |
| MemWrite | 0       | 0       | 0        | 0        | 0       | 0       | 0       | 0       | 0       | 1       | 0        | 0        | 0       | 0       | 0       | 0       |         |   |   |
| JR       | 0       | 0       | 0        | 0        | 0       | 0       | 0       | 0       | 0       | 0       | 0        | 0        | 0       | 0       | 0       | 0       | 1       |   |   |
| ExtOp_1  | x       | x       | x        | x        | x       | x       | x       | 0       | 0       | 0       | x        | x        | 1       | 0       | x       | x       |         |   |   |
| ExtOp_0  | x       | x       | x        | x        | x       | x       |         | 0       | 1       | 1       |          |          | 0       | 1       | x       | x       |         |   |   |
| ALUctr   | Add     | Add     | Subtract | Subtract | Or      | Sll     | Slt     | Or      | Add     | Add     | Subtract | Subtract | ADD     | ADD     | x       | x       |         |   |   |
| ALUctr_3 | 0       | 0       | 0        | 0        | 0       | 1       | 1       | 0       | 0       | 0       | 0        | 0        | 0       | 0       | x       | x       | 0       |   |   |
| ALUctr_2 | 0       | 0       | 1        | 1        | 0       | 0       | 0       | 0       | 0       | 0       | 1        | 1        | 0       | 0       | x       | x       | 0       |   |   |
| ALUctr_1 | 1       | 1       | 0        | 0        | 0       | 0       | 1       | 0       | 1       | 1       | 0        | 0        | 1       | 1       | x       | x       | 1       |   |   |
| ALUctr_0 | 1       | 1       | 0        | 0        | 1       | 1       | 1       | 1       | 1       | 1       | 0        | 0        | 1       | 1       | x       | x       | 1       |



7. nPC
将J型和beq指令整合
通过与Controller类似的对指令进行解析，得到下一个PC的数据并输入IFU中

|端口|方向|位宽|功能|
|--|--|--|--|
|op|input|[5:0]|指令op段|
|funct|input|[5:0]|指令funct段|
|PC|input|[31:0]|当前PC|
|imm|input|[15:0]|16位偏移量|
|addr|input|[25:0]|26位目标地址|
|ZERO|input|1|beq是否跳转|
|JAL|input|1|是否进行JAL指令（控制对31号寄存器写入）|
|NPC|output|[31:0]|输出下一个PC值|

内部nPC_sel对应的输出
| 000  | 001 | 010 | 011 |  |
|------|-----|-----|-----|-----|
| PC+4 | B   | J   | JAL |   |




测试方案
--
`add`指令
```
ori $a0, $0, 123
ori $a1, $a0, 456
lui $a2, 123            # 符号位为 0
lui $a3, 0xffff         # 符号位为 1
ori $a3, $a3, 0xffff    # $a3 = -1
add $s0, $a0, $a2      # 正正
add $s1, $a0, $a3      # 正负
add $s2, $a3, $a3      # 负负
```
`sub`指令
```
ori $a0, $0, 123
ori $a1, $a0, 456
lui $a2, 123            # 符号位为 0
lui $a3, 0xffff         # 符号位为 1
ori $a3, $a3, 0xffff    # $a3 = -1
sub $s0, $a0, $a2      # 正正
sub $s1, $a0, $a3      # 正负
sub $s2, $a3, $a3      # 负负
```
`lui`指令
```
ori $a0, $0, 123
ori $a1, $a0, 456
lui $a2, 123            # 符号位为 0
lui $a3, 0xffff         # 符号位为 1
```
`sw`指令
```
ori $a0, $0, 123
ori $a1, $a0, 456
lui $a2, 123            # 符号位为 0
lui $a3, 0xffff         # 符号位为 1
ori $a3, $a3, 0xffff    # $a3 = -1
add $s0, $a0, $a2      # 正正
add $s1, $a0, $a3      # 正负
add $s2, $a3, $a3      # 负负
sub $s0, $a0, $a2      # 正正
sub $s1, $a0, $a3      # 正负
sub $s2, $a3, $a3      # 负负
ori $t0, $0, 0x0008
sw $a0, -8($t0)
sw $a1, -4($t0)
sw $a2, 0($t0)
sw $a3, 12($t0)
sw $s0, 16($t0)
```
`lw` 指令
```
ori $a0, $0, 123
ori $a1, $a0, 456
lui $a2, 123            # 符号位为 0
lui $a3, 0xffff         # 符号位为 1
ori $a3, $a3, 0xffff    # $a3 = -1
add $s0, $a0, $a2      # 正正
add $s1, $a0, $a3      # 正负
add $s2, $a3, $a3      # 负负
sub $s0, $a0, $a2      # 正正
sub $s1, $a0, $a3      # 正负
sub $s2, $a3, $a3      # 负负
ori $t0, $0, 0x0008
sw $a0, -8($t0)
sw $a1, -4($t0)
lw $a2, -4($t0)
lw $a3, -8($t0)
sw $a0, 8($t0)
sw $a1, 0($t0)
lw $a2, 0($t0)
lw $a3, 8($t0)
```
`ori`指令
```
ori $a0, $0, 123
ori $a1, $a0, 456
```
`beq`指令
```
a:
beq $t0, $t0, c
b:
beq $t0, $t0, b
c:
beq $t0, $t0, b
```
思考题
--
1.  阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？
```
	addr信号来自于ALU的计算结果，因为设计的dm是字对齐，当执行如sb,lb,sh,lh等操作时，需要低两位进行字节、半字选择
```
2.  思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。
```
	指令对应的控制信号如何取值：
	exp:
		case(op)
			R型指令: begin
				case(funct)
					R型指令A: begin
						控制信号1 = ...
						控制信号2 = ...
					end
				...
				endcase
			end
			指令A: begin
				控制信号1 = ...
				控制信号2 = ...
				...
			end
			...
		endcase

	控制信号每种取值所对应的指令：
	exp:
		控制信号1 = 指令A | 指令B | ...
		控制信号2 = 指令A | 指令B | ...
	
	第一种方法：把某个指令选择的控制信号都集中在一起，更加直观。
	第二种方法：更加符合实际电路的连接。不直观。
```
3.  在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。
```
	同步复位：reset < clk
	异步复位：reset = clk
```
4.  C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。
```
    考虑溢出只是在不考虑溢出的基础上向外提供一个溢出信号，若不考虑溢出，二者等价。
```





