`always @(*)`里有`for`等循环语句时，要在开头对相关变量等变量（计数变量、最大值等）赋初值，如
~~~
always @(*) begin
        count = 0;
        for (loop = 0; loop < 32; loop = loop + 1) begin
            count = count + data[loop];
        end
        ...
    end
~~~

记录在某个状态停留了n个周期，进入该状态时计数器赋值为0，当计数器的值为n-1时作出改变

循环判断（识别后缀）和一次性判断

testbench:
1. 读入第一个数据时不要设置时延
2. 时钟周期要等于时延（暂）


`多输入下的状态转移逻辑`
`状态机端口是随时钟还是assign`

有符号数的移位
`e = $signed(a) >>> b 正确`
`e = a >>> b 不正确`
`e = $signed(a) >> b 不正确`

-   `assign C = (ALUOp==3'b101) ? $signed(A)>>>B : $signed(A+B);` 正确
-   `assign C = (ALUOp==3'b101) ? $signed(A)>>>B : A+B;` 错误
-   `assign C = (ALUOp==3'b101) ? $signed(A)>>>B : 0;` 正确 (**`0` 被看作有符号数**）
-   `assign C = (ALUOp==3'b101) ? $signed(A)>>>B : 32'b0;` 错误 (显式声明了进制, 被当成无符号数)
