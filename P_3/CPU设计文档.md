设计草稿
--
将32位单周期CPU分成IFU,GRF,ALU,DM,EXT,Controller,nPC六个部分，
分别对各个部分进行设计

1. IFU部分包括PC和IM（Introduction Memory），IM地址位宽为5

|端口|方向|位宽|功能|
|--|--|--|--|
|NPC|input|32|输入下一个PC
|RESET|input|1|重置PC
|CLK|input|1|时钟
|PC|output|[31:0]|输出当前PC
|Instr|output|[31:0]|输出指令


2. GRF包括32个32位寄存器

|端口|方向|位宽|功能|
|--|--|--|--|
|A1|input|[4:0]|第一个读取地址
|A2|input|[4:0]|第二个读取地址
|A3|input|[4:0]|写入地址
|WD|input|[31:0]|写入数据
|CLK|input|1|时钟
|RESET|input|1|重置
|RD1|output|[31:0]|第一个地址里的数据
|RD2|output|[31:0]|第二个地址里的数据

3. ALU实现多种运算

|端口|方向|位宽|功能|
|--|--|--|--|
|A|input|[31:0]|第一个操作数
|B|input|[31:0]|第二个操作数
|ALUctrl|input|[3:0]|功能控制信号
|ZERO|output|1|两个操作数是否相等
|C|output|[31:0]|运算结果

其中各个ALUctrl对应的功能
|ALUctrl|功能|
|--|--|
|0000|AandB|
|0001|AorB|
|0010|AxorB|
|0011|A+B|
|0100|A-B|
|0101|MUL_LO|
|0110|MUL_HI|
|0111|DIV_LO|
|1000|DIV_HI|
|1001|SLL|
|1010|SRL|
|1011|SLT|
|1100|SGE|

4. DM（Data Memory），位宽为5

|端口|方向|位宽|功能|
|--|--|--|--|
|A|input|[4:0]|选择地址|
|D|input|[31:0]|写入数据|
|WE|input|1|写使能|
|CLK|input|1|时钟|
|RESET|input|1|重置|
|D|output|[31:0]|读出数据|

5. EXT可以进行符号扩展、0扩展、16位数移到高位

|端口|方向|位宽|功能|
|--|--|--|--|
|ExtOp|input|[1:0]|控制信号
|imm16|input|[15:0]|输入16位立即数
|ext32|output|[31:0]|输出32位结果

|ExtOp|功能|
|--|--|
|00|零扩展|
|01|符号扩展|
|10|移高位|

6. Controller控制通路

|端口|方向|位宽|功能|
|--|--|--|--|
|op|input|[5:0]|指令op段|
|funct|input|[5:0]|指令funct段|
|RegDst|output|1|多路选择器开关|
|ALUsrc|output|1|多路选择器开关|
|MemtoReg|output|1|多路选择器开关|
|MemWrite|output|1|多路选择器开关|
|JR|output|1|是否进行JR指令|
|ExtOp|output|[1:0]|符号扩展信号|
|ALUctrl|output|[3:0]|ALU功能选择信号|

通路设计

| c        | 10_0000 | 10_0001 | 10_0010  | 10_0011  | 10_0101 | 00_0000 |         |         |         |         |          |          |         |         |         |         | 00_1000 |   |   |
|----------|---------|---------|----------|----------|---------|---------|---------|---------|---------|---------|----------|----------|---------|---------|---------|---------|---------|---|---|
| op       | 00_0000 | 00_0000 | 00_0000  | 00_0000  | 00_0000 | 00_0000 | 00_0000 | 00_1101 | 10_0011 | 10_1011 | 00_0101  | 00_0100  | 00_1111 | 00_1000 | 00_0010 | 00_0011 | 00_0000 |   |   |
|          | add     | addu    | sub      | subu     | or      | sll     | slt     | ori     | lw      | sw      | bne      | beq      | lui     | addi    | j       | jal     | jr      |   |   |
| RegDst   | 1       | 1       | 1        | 1        | 1       | 1       | 1       | 0       | 0       | x       | x        | x        | 0       | 0       | x       | x       |         |   |   |
| ALUSrc   | 0       | 0       | 0        | 0        | 0       | 0       | 0       | 1       | 1       | 1       | 0        | 0        | 1       | 1       | x       | x       |         |   |   |
| MemtoReg | 0       | 0       | 0        | 0        | 0       | 0       | 0       | 0       | 1       | x       | x        | x        | 0       | 0       | x       | 0       |         |   |   |
| RegWrite | 1       | 1       | 1        | 1        | 1       | 1       | 1       | 1       | 1       | 0       | 0        | 0        | 1       | 1       | 0       | 1       |         |   |   |
| MemWrite | 0       | 0       | 0        | 0        | 0       | 0       | 0       | 0       | 0       | 1       | 0        | 0        | 0       | 0       | 0       | 0       |         |   |   |
| JR       | 0       | 0       | 0        | 0        | 0       | 0       | 0       | 0       | 0       | 0       | 0        | 0        | 0       | 0       | 0       | 0       | 1       |   |   |
| ExtOp_1  | x       | x       | x        | x        | x       | x       | x       | 0       | 0       | 0       | x        | x        | 1       | 0       | x       | x       |         |   |   |
| ExtOp_0  | x       | x       | x        | x        | x       | x       |         | 0       | 1       | 1       |          |          | 0       | 1       | x       | x       |         |   |   |
| ALUctr   | Add     | Add     | Subtract | Subtract | Or      | Sll     | Slt     | Or      | Add     | Add     | Subtract | Subtract | ADD     | ADD     | x       | x       |         |   |   |
| ALUctr_3 | 0       | 0       | 0        | 0        | 0       | 1       | 1       | 0       | 0       | 0       | 0        | 0        | 0       | 0       | x       | x       | 0       |   |   |
| ALUctr_2 | 0       | 0       | 1        | 1        | 0       | 0       | 0       | 0       | 0       | 0       | 1        | 1        | 0       | 0       | x       | x       | 0       |   |   |
| ALUctr_1 | 1       | 1       | 0        | 0        | 0       | 0       | 1       | 0       | 1       | 1       | 0        | 0        | 1       | 1       | x       | x       | 1       |   |   |
| ALUctr_0 | 1       | 1       | 0        | 0        | 1       | 1       | 1       | 1       | 1       | 1       | 0        | 0        | 1       | 1       | x       | x       | 1       |



7. nPC
将J型和beq指令整合
通过与Controller类似的对指令进行解析，得到下一个PC的数据并输入IFU中

|端口|方向|位宽|功能|
|--|--|--|--|
|op|input|[5:0]|指令op段|
|funct|input|[5:0]|指令funct段|
|PC|input|[31:0]|当前PC|
|imm|input|[15:0]|16位偏移量|
|addr|input|[25:0]|26位目标地址|
|ZERO|input|1|beq是否跳转|
|JAL|input|1|是否进行JAL指令（控制对31号寄存器写入）|
|NPC|output|[31:0]|输出下一个PC值|

内部nPC_sel对应的输出
| 000  | 001 | 010 | 011 |  |
|------|-----|-----|-----|-----|
| PC+4 | B   | J   | JAL |   |




测试方案
--
`add`指令
```
ori $a0, $0, 123
ori $a1, $a0, 456
lui $a2, 123            # 符号位为 0
lui $a3, 0xffff         # 符号位为 1
ori $a3, $a3, 0xffff    # $a3 = -1
add $s0, $a0, $a2      # 正正
add $s1, $a0, $a3      # 正负
add $s2, $a3, $a3      # 负负
```
`sub`指令
```
ori $a0, $0, 123
ori $a1, $a0, 456
lui $a2, 123            # 符号位为 0
lui $a3, 0xffff         # 符号位为 1
ori $a3, $a3, 0xffff    # $a3 = -1
sub $s0, $a0, $a2      # 正正
sub $s1, $a0, $a3      # 正负
sub $s2, $a3, $a3      # 负负
```
`lui`指令
```
ori $a0, $0, 123
ori $a1, $a0, 456
lui $a2, 123            # 符号位为 0
lui $a3, 0xffff         # 符号位为 1
```
`sw`指令
```
ori $a0, $0, 123
ori $a1, $a0, 456
lui $a2, 123            # 符号位为 0
lui $a3, 0xffff         # 符号位为 1
ori $a3, $a3, 0xffff    # $a3 = -1
add $s0, $a0, $a2      # 正正
add $s1, $a0, $a3      # 正负
add $s2, $a3, $a3      # 负负
sub $s0, $a0, $a2      # 正正
sub $s1, $a0, $a3      # 正负
sub $s2, $a3, $a3      # 负负
ori $t0, $0, 0x0008
sw $a0, -8($t0)
sw $a1, -4($t0)
sw $a2, 0($t0)
sw $a3, 12($t0)
sw $s0, 16($t0)
```
`lw` 指令
```
ori $a0, $0, 123
ori $a1, $a0, 456
lui $a2, 123            # 符号位为 0
lui $a3, 0xffff         # 符号位为 1
ori $a3, $a3, 0xffff    # $a3 = -1
add $s0, $a0, $a2      # 正正
add $s1, $a0, $a3      # 正负
add $s2, $a3, $a3      # 负负
sub $s0, $a0, $a2      # 正正
sub $s1, $a0, $a3      # 正负
sub $s2, $a3, $a3      # 负负
ori $t0, $0, 0x0008
sw $a0, -8($t0)
sw $a1, -4($t0)
lw $a2, -4($t0)
lw $a3, -8($t0)
sw $a0, 8($t0)
sw $a1, 0($t0)
lw $a2, 0($t0)
lw $a3, 8($t0)
```
`ori`指令
```
ori $a0, $0, 123
ori $a1, $a0, 456
```
`beq`指令
```
a:
beq $t0, $t0, c
b:
beq $t0, $t0, b
c:
beq $t0, $t0, b
```
思考题
--
1.  上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法，请大家画出单周期 CPU 对应有限状态机的状态转移图，并谈谈它和我们之前见过的状态转移图有什么不同。
```
	(图用markdown画不好~)
    以splitter为界，“上下游”分别是一个Mealy型有限状态机。
    上游：若无跳转指令（b类j类），PC = PC + 4；否则跳转到目标位置。跳转指令可视为输入信号，当前PC值可视为当前状态，PC改变后输出的instruction视为输出。满足Mealy型有限状态机。
    下游：instruction分解的各个信号，通过controller控制各个通路的选择和选择不同的寄存器，然后经过ALU的逻辑运算，得到结果并在下一个时钟沿写入相应的寄存器或存储器中。整个下游部分可视作一个mealy型状态机，instruction是输入，GRF和DM的组合是状态，跳转指令可视为输出。

```
2.  现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。
	```
	在本题中合理，ALU对DM进行读写，CPU运行过程中不对IM进行写入，GRF高效的需要读写。
	但 实际上，我们通过I/O接口进行读写指令，所以IM也应该使用RAM。
	```
3.  在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。
	```
	我设计了nPC模块，见上文
	```
4.  事实上，实现 `nop` 空指令，我们并不需要将它加入控制信号真值表，为什么？
    ```
    寄存器写入信号RegWrite、数据存储器读写信号MemWrite、MemToReg均为0，接受nop信号时即使ALU在进行相关的计算，但并不会改变GRF和DM中的数值。
	```
5.  上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。
    ```
    当地址大于0x3000时减去0x3000
	```
6.  阅读 Pre 的 [“MIPS 指令集及汇编语言”](http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/) 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。
	```
	1. sw lw没有负数偏移量进行测试
	2. beq没有对后跳进行测试
	3. 没有对sub进行测试！！！！！！！！！！！
	```




